//===-- CPU74ISelDAGToDAG.cpp - A dag to dag inst selector for CPU74 ----===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the CPU74 target.
//
//===----------------------------------------------------------------------===//

#include "CPU74.h"
#include "CPU74TargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/Config/llvm-config.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "cpu74-isel"

//namespace {
//  struct CPU74ISelAddressMode {
//    enum {
//      RegBase,
//      FrameIndexBase
//    } BaseType;
//
//    struct {            // This is really a union, discriminated by BaseType!
//      SDValue Reg;
//      int FrameIndex;
//    } Base;
//
//    int16_t Disp;
//    const GlobalValue *GV;
//    const Constant *CP;
//    const BlockAddress *BlockAddr;
//    const char *ES;
//    int JT;
//    unsigned Align;    // CP alignment.
//
//    CPU74ISelAddressMode()
//      : BaseType(RegBase), Disp(0), GV(nullptr), CP(nullptr),
//        BlockAddr(nullptr), ES(nullptr), JT(-1), Align(0) {
//    }
//
//    bool hasSymbolicDisplacement() const {
//      return GV != nullptr || CP != nullptr || ES != nullptr || JT != -1;
//    }
//
//#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
//    LLVM_DUMP_METHOD void dump() {
//      errs() << "CPU74ISelAddressMode " << this << '\n';
//      if (BaseType == RegBase && Base.Reg.getNode() != nullptr) {
//        errs() << "Base.Reg ";
//        Base.Reg.getNode()->dump();
//      } else if (BaseType == FrameIndexBase) {
//        errs() << " Base.FrameIndex " << Base.FrameIndex << '\n';
//      }
//      errs() << " Disp " << Disp << '\n';
//      if (GV) {
//        errs() << "GV ";
//        GV->dump();
//      } else if (CP) {
//        errs() << " CP ";
//        CP->dump();
//        errs() << " Align" << Align << '\n';
//      } else if (ES) {
//        errs() << "ES ";
//        errs() << ES << '\n';
//      } else if (JT != -1)
//        errs() << " JT" << JT << " Align" << Align << '\n';
//    }
//#endif
//  };
//}

/// CPU74DAGToDAGISel - CPU74 specific code to select CPU74 machine
/// instructions for SelectionDAG operations.
///
namespace
{
  class CPU74DAGToDAGISel : public SelectionDAGISel
  {
  public:
    CPU74DAGToDAGISel(CPU74TargetMachine &TM, CodeGenOpt::Level OptLevel)
        : SelectionDAGISel(TM, OptLevel) {}

    StringRef getPassName() const override {
      return "CPU74 DAG->DAG Pattern Instruction Selection";
    }

  // Include the pieces autogenerated from the target description.
  #include "CPU74GenDAGISel.inc"
  
  
  typedef bool (*ImmTestF)(int);

  private:
    void Select(SDNode *N) override;
    
    bool SelectARIndexed(SDValue N, SDValue &Base, SDValue &OffImm);
    bool SelectFIIndexed(SDValue N, SDValue &Base, SDValue &OffImm);
    bool SelectIndexed(SDValue N, SDValue &Base, SDValue &OffImm);
    bool SelectWordIndexed(SDValue N, SDValue &Base, SDValue &OffImm);
    bool SelectAddress(SDValue N, SDValue &Base);

    bool doSelectFrameIndexed(SDValue N, SDValue &Base, SDValue &OffImm);
    bool doSelectMemoryIndexed(SDValue N, SDValue &Base, SDValue &OffImm, ImmTestF immTest );
    bool doSelectMemoryIndexedWrapper(SDValue N, SDValue &Base, SDValue &Offset );
    bool doSelectAddress(SDValue N, SDValue &Base);
  };
}  // end anonymous namespace



/// createCPU74ISelDag - This pass converts a legalized DAG into a
/// CPU74-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createCPU74ISelDag(CPU74TargetMachine &TM,
                                        CodeGenOpt::Level OptLevel) {
  return new CPU74DAGToDAGISel(TM, OptLevel);
}



static void aveureque( SDValue Addr  )
{
    unsigned last = ISD::BUILTIN_OP_END;
    unsigned opCode = 0;
    ISD::NodeType opCodeNT = ISD::DELETED_NODE;
    CPU74ISD::NodeType opCode74NT = CPU74ISD::FIRST_NUMBER;
  
    ISD::NodeType zzz0NT = ISD::DELETED_NODE;
    CPU74ISD::NodeType zzz074NT = CPU74ISD::FIRST_NUMBER;
  
    ISD::NodeType zzz1NT = ISD::DELETED_NODE;
    CPU74ISD::NodeType zzz174NT = CPU74ISD::FIRST_NUMBER;
  
  if ( !Addr.getNode() )
      return;
  
    opCode = Addr->getOpcode();
    opCodeNT = (ISD::NodeType)opCode;
    opCode74NT = CPU74ISD::FIRST_NUMBER;
    if ( opCode > CPU74ISD::FIRST_NUMBER ) opCode74NT = (CPU74ISD::NodeType)opCodeNT;
  
    if ( Addr.getNumOperands()>0)
    {
      SDValue oper0 = Addr.getOperand(0);
      unsigned zzz0 = oper0.getOpcode();
      zzz0NT = (ISD::NodeType)zzz0;
      if ( zzz0 > CPU74ISD::FIRST_NUMBER ) zzz074NT = (CPU74ISD::NodeType)zzz0;
    }
    if ( Addr.getNumOperands()>1)
    {
      SDValue oper1 = Addr.getOperand(1);
      unsigned zzz1 = oper1.getOpcode();
      zzz1NT = (ISD::NodeType)zzz1;
      if ( zzz1 > CPU74ISD::FIRST_NUMBER ) zzz174NT = (CPU74ISD::NodeType)zzz1;
    }
  int a=2;
}

// Only selects Frame Index [fp,k]. Example: movw_qr, movw_rq, lea_qr
bool CPU74DAGToDAGISel::SelectFIIndexed(SDValue Addr, SDValue &Base, SDValue &Offset)
{
  return doSelectFrameIndexed(Addr, Base, Offset);
}

// Address with short immediates, but not Frame Indexes [Rx,k]. Example: movw_mr, movw_rm, lea_mr
bool CPU74DAGToDAGISel::SelectARIndexed(SDValue Addr, SDValue &Base, SDValue &Offset)
{
  ImmTestF immTest = [](int constant) -> bool { return CPU74Imm::isImm5_d(constant); };
  return doSelectMemoryIndexed(Addr, Base, Offset, immTest);
}

// Address with short immediates, and Frame Indexes [Rx,k], [fp,k] . Example: movw_mr, movw_rm, lea_mr
bool CPU74DAGToDAGISel::SelectIndexed(SDValue Addr, SDValue &Base, SDValue &Offset)
{
  if ( doSelectFrameIndexed(Addr, Base, Offset) )
    return true;
  
  ImmTestF immTest = [](int constant) -> bool { return CPU74Imm::isImm5_d(constant); };
  return doSelectMemoryIndexed(Addr, Base, Offset, immTest);
}

// Address with long immediates, but not Frame Indexes [Rx,K] . Example: movw_Mr, movw_rM, lea_Mr
bool CPU74DAGToDAGISel::SelectWordIndexed(SDValue Addr, SDValue &Base, SDValue &Offset)
{
  if ( doSelectMemoryIndexedWrapper(Addr, Base, Offset) )
    return true;

  ImmTestF immTest = [](int constant) -> bool { return !CPU74Imm::isImm5_d(constant); };
  return doSelectMemoryIndexed(Addr, Base, Offset, immTest);
}

// Direct addresses of the form [&Addr]
bool CPU74DAGToDAGISel::SelectAddress(SDValue Addr, SDValue &Base)
{
  return doSelectAddress(Addr, Base);
}

// [SP, k]
bool CPU74DAGToDAGISel::doSelectFrameIndexed(SDValue Addr, SDValue &Base, SDValue &Offset)
{
  SDLoc DL(Addr);
  EVT ValTy = Addr.getValueType();

  SDValue &EntryNode = Addr;
  int constant = 0;
  
  aveureque( EntryNode );
  
  // Base with constant offset may be an indexed stack access
  // so try to select it
  if (CurDAG->isBaseWithConstantOffset(EntryNode))
  {
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    constant = CN->getZExtValue();
    EntryNode = EntryNode.getOperand(0);
    aveureque( EntryNode );
    // Fall through
  }
  
  // If the address is a frame index get the TargetFrameIndex.
  // These are simple-type function arguments or local vars
  if (const FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(EntryNode))
  {
    int idx = FIN->getIndex();
    Base = CurDAG->getTargetFrameIndex(idx, ValTy);    // target frame index
    Offset = CurDAG->getTargetConstant(constant, DL, ValTy);  // set constant zero
    //ensureFrameObjectAlignment( idx );
    return true;
  }
  
  if ( !CPU74Imm::isImm8u(constant) )  // Should be selected by MOVMr
      return false;
  
  unsigned opCode = EntryNode.getOpcode();
  if (  opCode == CPU74ISD::CallArgLoc )
  {
    assert( CPU74Imm::isImm8u(constant) && "Too big, sorry" );
    //Base = CurDAG->getCopyFromReg(Chain, dl, CPU74::SP, PtrVT);
    Base = CurDAG->getRegister(CPU74::SP, ValTy);
    Offset = CurDAG->getTargetConstant(constant, DL, ValTy);
    return true;
  }
  
  return false;
}

// [R, k]
bool CPU74DAGToDAGISel::doSelectMemoryIndexed(SDValue Addr, SDValue &Base, SDValue &Offset, ImmTestF immTest)
{
  SDLoc DL(Addr);
  EVT ValTy = Addr.getValueType();

  SDValue &EntryNode = Addr;
  int64_t constant = 0;
  
  aveureque( EntryNode );
  
  // Base with constant offset
  if (CurDAG->isBaseWithConstantOffset(EntryNode))
  {
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    constant = CN->getSExtValue();
    EntryNode = EntryNode.getOperand(0);
    aveureque( EntryNode );
    // Fall through
  }

  // Constants not in the expected range can't be selected
  if ( !immTest(constant) )
    return false;
  
  // Select CallArgLog in case it was not by doSelectFrameIndexed
  unsigned opCode = EntryNode.getOpcode();
  if (  opCode == CPU74ISD::CallArgLoc )
  {
    Base = CurDAG->getRegister(CPU74::SP, ValTy);
    Offset = CurDAG->getTargetConstant(constant, DL, ValTy);
    return true;
  }
  
  // Select unless it's frame stuff or it contains a non constant embeeded add
  if ( !( dyn_cast<FrameIndexSDNode>(EntryNode) /*|| opCode == CPU74ISD::CallArgLoc */ // This shall be selected by MOVqr or MOVrq
        || opCode == ISD::ADD           // This should be selected by MOVnr or MOVrn
        //|| opCode == CPU74ISD::SingleValWrapper   // This shall be selected by MOVar or MOVra
        || (opCode == CPU74ISD::AggregateWrapper && EntryNode.hasOneUse()) ) )  // This should be selected by MOVar or MOVra
  {
    Base = EntryNode;
    Offset = CurDAG->getTargetConstant(constant, DL, ValTy);
    return true;
  }
  
  return false;
}

// [R, &a]
bool CPU74DAGToDAGISel::doSelectMemoryIndexedWrapper(SDValue Addr, SDValue &Base, SDValue &Offset )
{
  SDLoc DL(Addr);
  EVT ValTy = Addr.getValueType();

  SDValue &EntryNode = Addr;
  
  aveureque( EntryNode );
  
  unsigned opCode = EntryNode.getOpcode();
  
  if ( opCode == ISD::ADD )
  {
    SDValue N0 = EntryNode.getOperand(0);
    SDValue N1 = EntryNode.getOperand(1);
    
    // We want the wrapper in the second place so swap operands if necessary
    if (N0.getOpcode() == CPU74ISD::AggregateWrapper )
    {
      SDValue Tmp = N0;
      N0 = N1;
      N1 = Tmp;
    }
    
    // Select only if this is a one use wrapper and the other node is not a constant
    if ( N1.getOpcode() == CPU74ISD::AggregateWrapper && N1.hasOneUse()
            && !dyn_cast<ConstantSDNode>(N0))
    {
      Base = N0;
      Offset = N1.getOperand(0);
      return true;
    }
  }
  
  return false;
}

// [&a],  [&a+cnst]
bool CPU74DAGToDAGISel::doSelectAddress(SDValue Addr, SDValue &Base)
{
  SDLoc DL(Addr);
  EVT ValTy = Addr.getValueType();

  SDValue &EntryNode = Addr;
  int64_t constant = 0;
  
  aveureque( EntryNode );
  
  // Base with constant offset
  if (CurDAG->isBaseWithConstantOffset(EntryNode))
  {
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    constant = CN->getSExtValue();
    EntryNode = EntryNode.getOperand(0);
    aveureque( EntryNode );
    // Fall through
  }
  
  // Select only if the base is a one use wrapper
  if ( EntryNode.getOpcode() == CPU74ISD::AggregateWrapper && EntryNode.hasOneUse() )
  {
    SDValue Op = EntryNode.getOperand(0);
    const GlobalValue *GV = cast<GlobalAddressSDNode>(Op)->getGlobal();
    int64_t offset = cast<GlobalAddressSDNode>(Op)->getOffset();
    
    // fold the incomming offset with the constand add
    Base = CurDAG->getTargetGlobalAddress(GV, DL, ValTy, constant+offset);
    return true;
  }
  
  return false;
}

void CPU74DAGToDAGISel::Select(SDNode *Node)
{
  SDLoc dl(Node);

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode())
  {
    LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  unsigned opCode = Node->getOpcode();
  ISD::NodeType opCodeNT = (ISD::NodeType)opCode;
  CPU74ISD::NodeType zzz074NT = CPU74ISD::FIRST_NUMBER;
  if ( opCode > CPU74ISD::FIRST_NUMBER ) zzz074NT = (CPU74ISD::NodeType)opCodeNT;

  EVT ValTy = Node->getValueType(0);
  
  if ( opCode == CPU74ISD::CallArgLoc )
  {
      SDValue Base = CurDAG->getRegister( CPU74::SP, ValTy);
      SDValue Offset = CurDAG->getTargetConstant(0, dl, MVT::i16);
      CurDAG->SelectNodeTo(Node, CPU74::LEAqr16_core, ValTy, Base, Offset);
      return;
  }

//  if ( 0 && opCode == ISD::FrameIndex )
//  {
//      FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Node);
//      int idx = FIN->getIndex();
//      SDValue Base = CurDAG->getTargetFrameIndex(idx, ValTy);
//      SDValue Offset = CurDAG->getTargetConstant(0, dl, ValTy);
//      //CurDAG->SelectNodeTo(Node, CPU74::ADDFrame, ValTy, Base, Offset);
//
//      CurDAG->SelectNodeTo(Node, CPU74::LEAqr16, ValTy, Base, Offset); 
//      //CurDAG->SelectNodeTo(Node, CPU74::LEAMr16, ValTy, Base, Offset);
//      //ensureFrameObjectAlignment( idx );
//      return;
//  }
  
//  if ( 0 && CurDAG->isBaseWithConstantOffset( SDValue(Node,0)) )
//  {
//    SDValue wrapN = Node->getOperand(0);
//    if ( wrapN.getOpcode() == CPU74ISD::AggregateWrapper )
//    {
//      if ( wrapN.hasOneUse() )
//      {
//        ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Node->getOperand(1));
//        int64_t offset = CN->getSExtValue();
//
//        const GlobalValue *GV = cast<GlobalAddressSDNode>(wrapN.getOperand(0))->getGlobal();
//
//        SDValue tgaN = CurDAG->getTargetGlobalAddress(GV, dl, ValTy, offset);
//        CurDAG->SelectNodeTo(Node, CPU74ISD::SingleValWrapper, ValTy, tgaN);
//        return;
//      }
//    }
//  }



  // Other cases are autogenerated
  // Select the default instruction
  SelectCode(Node);
}



